---
title: "Lab 06"
author: "Biology Student"
date: "20 Feb 2019"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Loading Libraries

```{r Load Libraries, include=FALSE}
if (!require("tidyverse")) install.packages("tidyverse"); library(tidyverse)
```

## Objectives for Lab 6

1. Working with time series
2. Clustering
3. Dimension Reduction

## Background

We will be using the dataset from a Driven Data competition: 
https://www.drivendata.org/competitions/44/dengai-predicting-disease-spread/

The data for this competition comes from multiple sources aimed at supporting the Predict the Next Pandemic Initiative (https://www.whitehouse.gov/blog/2015/06/05/back-future-using-historical-dengue-data-predict-next-epidemic). 
Dengue surveillance data is provided by the U.S. Centers for Disease Control and prevention, as well as the Department of Defense's Naval Medical Research Unit 6 and the Armed Forces Health Surveillance Center, in collaboration with the Peruvian government and U.S. universities. 
Environmental and climate data is provided by the National Oceanic and Atmospheric Administration (NOAA), an agency of the U.S. Department of Commerce.

The data is provided in two separate files:

1. dengue_features_train: weekly weather and vegetation data for two cities
2. dengue_labels_train: weekly number of dengue cases in each city

There are two cities, San Juan, Puerto Rico and Iquitos, Peru, with test data for each city spanning 5 and 3 years respectively. The data for each city have been concatenated along with a city column indicating the source: *sj* for San Juan and *iq* for Iquitos. 

```{r Read Data}
dengue_features_train <- read_csv("https://s3.amazonaws.com/drivendata/data/44/public/dengue_features_train.csv")
str(dengue_features_train)
summary(dengue_features_train)
dengue_labels_train <- read_csv("https://s3.amazonaws.com/drivendata/data/44/public/dengue_labels_train.csv")
str(dengue_labels_train)
summary(dengue_labels_train)
```

## Feature Descriptions

You are provided the following set of information on a (year, weekofyear) timescale:

(Where appropriate, units are provided as a _unit suffix on the feature name.)

City and date indicators

- city – City abbreviations: sj for San Juan and iq for Iquitos
- week_start_date – Date given in yyyy-mm-dd format

NOAA's GHCN daily climate data weather station measurements

- station_max_temp_c – Maximum temperature
- station_min_temp_c – Minimum temperature
- station_avg_temp_c – Average temperature
- station_precip_mm – Total precipitation
- station_diur_temp_rng_c – Diurnal temperature range

PERSIANN satellite precipitation measurements (0.25x0.25 degree scale)

- precipitation_amt_mm – Total precipitation

NOAA's NCEP Climate Forecast System Reanalysis measurements (0.5x0.5 degree scale)

- reanalysis_sat_precip_amt_mm – Total precipitation
- reanalysis_dew_point_temp_k – Mean dew point temperature
- reanalysis_air_temp_k – Mean air temperature
- reanalysis_relative_humidity_percent – Mean relative humidity
- reanalysis_specific_humidity_g_per_kg – Mean specific humidity
- reanalysis_precip_amt_kg_per_m2 – Total precipitation
- reanalysis_max_air_temp_k – Maximum air temperature
- reanalysis_min_air_temp_k – Minimum air temperature
- reanalysis_avg_temp_k – Average air temperature
- reanalysis_tdtr_k – Diurnal temperature range

Satellite vegetation - Normalized difference vegetation index (NDVI) - NOAA's CDR Normalized Difference Vegetation Index (0.5x0.5 degree scale) measurements

- ndvi_se – Pixel southeast of city centroid
- ndvi_sw – Pixel southwest of city centroid
- ndvi_ne – Pixel northeast of city centroid
- ndvi_nw – Pixel northwest of city centroid

## Separate Data by city

Use dplyr to filter the data frame by city.
Then check that the numbers of rows are what you expect.

```{r}
sj_train_features <-
sj_train_labels   <-

iq_train_features <-
iq_train_labels   <-
```

## Time Series and Calculations

```{r}
CurrentTime <- Sys.time()
weekdays(CurrentTime)
unclass(CurrentTime)  # Number of seconds since 1970-01-01
CurrentDate <- Sys.Date()
unclass(CurrentDate) # Number of days since 1970-01-01
x <- as.Date("2012-01-01")
y <- strptime("9 Jan 2011 11:34:21", "%d %b %Y %H:%M:%S")
?strptime
CurrentDate - x
CurrentTime - y
```

Explore the week_start_date columns in the filtered data

```{r}
#sj_train_features$week_start_date
#iq_train_features$week_start_date
```

## Plotting Time Series Data

```{r}
ggplot(iq_train_features, aes(week_start_date, station_avg_temp_c)) + 
  geom_line() +
  xlab("Date") + 
  ylab("Station Average Temp (C)") +
  theme_minimal()
```

Use ggplot to visualize two categories on the same plot

```{r}
ggplot(dengue_features_train, aes(x = week_start_date, y = precipitation_amt_mm)) + 
  geom_line(aes(color = city)) +
  scale_color_manual(values = c("#00AFBB", "#E7B800")) +
  theme_minimal()
```



## Decompose Time Series

As you might expect, there is a seasonal rhythm to the precipitation data. 
Built in to R there are some sophisticated ways to analyze the seasonal component of the variable: decompose()

```{r}
station_avg_temp_c.components <- decompose(select(iq_train_features, c(week_start_date, station_avg_temp_c)))
```

However these two locations are too close to the equator to give us a strong enough seasonal signal for decompose() to recognize!

There is much that can be done with time series, including model fits and forecasting:
https://a-little-book-of-r-for-time-series.readthedocs.io/en/latest/src/timeseries.html

## Clustering

Next we will follow *Exploratory Data Analysis with R* Chapters 12 and 13 
https://leanpub.com/exdata/read_full

Unfortunately the Dengue dataset is not well-suited for clustering analysis. 
So we will have to put it aside for now and use our good old friend iris.
We will start with just two dimensions of the data, to assist us with visualization.

```{r}
data("iris")
str(iris)
ggplot(iris, aes(x=Petal.Length, y=Petal.Width, color=Species)) +
  geom_point() +
  theme_minimal()
```

It was cheating to use species, so now lets try to cluster the data based on the variables.

```{r}
hClustering <- data.frame(x=iris$Petal.Length,y=iris$Petal.Width) %>% dist %>% hclust
plot(hClustering)
```

How many clusters are there?
It depends on where you cut the tree.

```{r}
ggplot(iris, aes(x=Petal.Length, y=Petal.Width, color=as.factor(cutree(hClustering, h=4)))) +
  geom_point() +
  scale_colour_discrete(name  ="Cluster") +
  theme_minimal()
ggplot(iris, aes(x=Petal.Length, y=Petal.Width, color=as.factor(cutree(hClustering, h=2)))) +
  geom_point() +
  scale_colour_discrete(name  ="Cluster") +
  theme_minimal()
```

Now use all of the variables to try to come up with a better cluster

```{r}
fullClustering <- iris %>% select(-Species) %>% dist %>% hclust
plot(fullClustering)
```

```{r}
ggplot(iris, aes(x=Petal.Length, y=Petal.Width, color=as.factor(cutree(fullClustering, h=4)))) +
  geom_point() +
  scale_colour_discrete(name  ="Cluster") +
  theme_minimal()
```

## K-Means Clustering

K-Means is an alternative clustering algorithm that starts with a fixed number of clusters and then determines the best way to fit the data to that number.

```{r}
kmeansObj <-iris %>% select(-Species) %>% kmeans(centers = 3)
names(kmeansObj)
kmeansObj$cluster

```

```{r}
ggplot(iris, aes(x=Petal.Length, y=Petal.Width, color=as.factor(kmeansObj$cluster))) +
  geom_point() +
  scale_colour_discrete(name  ="Cluster") +
  theme_minimal()
```

Are the clusters identical from the two methods?
Which better matches the species designations?

## Heatmaps

We can also explore the data using a heatmap. The rows are ordered based on the order of the hierarchical clustering (using the “complete” method). The colored bar indicates the species category each row belongs to. The color in the heatmap indicates the length of each measurement (from light yellow to dark red).

In the heatmap we also see how the Setosa species has low petal values (in light yellow), but it is very difficult to see any clear distinction between the other two species.

https://cran.r-project.org/web/packages/dendextend/vignettes/Cluster_Analysis.html

```{r}
install.packages("dendextend")
library(dendextend)
iris2 <- iris[,-5]
species_labels <- iris[,5]
labels_colors(fullClustering) <-
   rainbow(3)[sort_levels_values(
      as.numeric(iris[,5])[order.dendrogram(fullClustering)]
   )]
dend <- as.dendrogram(fullClustering)
scaled_iris <- iris2 %>% as.matrix %>% scale
library(pheatmap)
library(gplots)
pheatmap(as.matrix(scaled_iris), 
          main = "Heatmap for the Iris data set",
          srtCol = 20,
          dendrogram = "row",
          Rowv = dend,
          Colv = "NA", # this to make sure the columns are not ordered
          trace="none",          
          margins =c(5,0.1),      
          key.xlab = "Cm",
          denscol = "grey",
          density.info = "density",
          RowSideColors = rev(labels_colors(dend)) # to add nice colored strips        
         )
```

